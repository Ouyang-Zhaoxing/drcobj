THREE.DRACOExporter=function(){},THREE.DRACOExporter.prototype={constructor:THREE.DRACOExporter,parse:function(e,r){if(!0===e.isBufferGeometry||!0===e.isGeometry)throw new Error("DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.");if(void 0===DracoEncoderModule)throw new Error("THREE.DRACOExporter: required the draco_decoder to work.");void 0===r&&(r={decodeSpeed:5,encodeSpeed:5,encoderMethod:THREE.DRACOExporter.MESH_EDGEBREAKER_ENCODING,quantization:[16,8,8,8,8],exportUvs:!0,exportNormals:!0,exportColor:!1});var o,t,E,i=e.geometry,n=DracoEncoderModule(),d=new n.Encoder;if(!0===i.isGeometry&&((E=new THREE.BufferGeometry).setFromObject(e),i=E),!0!==i.isBufferGeometry)throw new Error("THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.Geometry or THREE.BufferGeometry instance.");if(!0===e.isMesh){o=new n.MeshBuilder,t=new n.Mesh;var a,A=i.getAttribute("position");if(o.AddFloatAttributeToMesh(t,n.POSITION,A.count,A.itemSize,A.array),null!==(R=i.getIndex()))o.AddFacesToMesh(t,R.count/3,R.array);else{for(var R=new(65535<A.count?Uint32Array:Uint16Array)(A.count),u=0;u<R.length;u++)R[u]=u;o.AddFacesToMesh(t,A.count,R)}!0!==r.exportNormals||void 0!==(a=i.getAttribute("normal"))&&o.AddFloatAttributeToMesh(t,n.NORMAL,a.count,a.itemSize,a.array),!0!==r.exportUvs||void 0!==(a=i.getAttribute("uv"))&&o.AddFloatAttributeToMesh(t,n.TEX_COORD,a.count,a.itemSize,a.array),!0===r.exportColor&&void 0!==(p=i.getAttribute("color"))&&o.AddFloatAttributeToMesh(t,n.COLOR,p.count,p.itemSize,p.array)}else{if(!0!==e.isPoints)throw new Error("DRACOExporter: Unsupported object type.");o=new n.PointCloudBuilder,t=new n.PointCloud;A=i.getAttribute("position");o.AddFloatAttribute(t,n.POSITION,A.count,A.itemSize,A.array),!0===r.exportColor&&void 0!==(p=i.getAttribute("color"))&&o.AddFloatAttribute(t,n.COLOR,p.count,p.itemSize,p.array)}var s,c=new n.DracoInt8Array,i=void 0!==r.encodeSpeed?r.encodeSpeed:5,p=void 0!==r.decodeSpeed?r.decodeSpeed:5;if(d.SetSpeedOptions(i,p),void 0!==r.encoderMethod&&d.SetEncodingMethod(r.encoderMethod),void 0!==r.quantization)for(u=0;u<5;u++)void 0!==r.quantization[u]&&d.SetAttributeQuantization(u,r.quantization[u]);if(s=!0===e.isMesh?d.EncodeMeshToDracoBuffer(t,c):d.EncodePointCloudToDracoBuffer(t,!0,c),n.destroy(t),0===s)throw new Error("THREE.DRACOExporter: Draco encoding failed.");for(var O=new Int8Array(new ArrayBuffer(s)),u=0;u<s;u++)O[u]=c.GetValue(u);return n.destroy(c),n.destroy(d),n.destroy(o),O}},THREE.DRACOExporter.MESH_EDGEBREAKER_ENCODING=1,THREE.DRACOExporter.MESH_SEQUENTIAL_ENCODING=0,THREE.DRACOExporter.POINT_CLOUD=0,THREE.DRACOExporter.TRIANGULAR_MESH=1,THREE.DRACOExporter.INVALID=-1,THREE.DRACOExporter.POSITION=0,THREE.DRACOExporter.NORMAL=1,THREE.DRACOExporter.COLOR=2,THREE.DRACOExporter.TEX_COORD=3,THREE.DRACOExporter.GENERIC=4;