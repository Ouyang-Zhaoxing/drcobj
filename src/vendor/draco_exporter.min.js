THREE.DRACOExporter=function(){},THREE.DRACOExporter.prototype={constructor:THREE.DRACOExporter,parse:function(colors,options){if(void 0===DracoEncoderModule)throw new Error("THREE.DRACOExporter: required the draco_decoder to work.");void 0===options&&(options={decodeSpeed:5,encodeSpeed:5,encoderMethod:THREE.DRACOExporter.MESH_EDGEBREAKER_ENCODING,quantization:[16,8,8,8,8],exportUvs:!0,exportNormals:!0,exportColor:!1});var dracoEncoder=DracoEncoderModule(),encoder=new dracoEncoder.Encoder,builder=new dracoEncoder.MeshBuilder,mesh=new dracoEncoder.Mesh;if(!0===colors.isGeometry&&((vertices=new THREE.BufferGeometry).fromGeometry(colors),colors=vertices),!0!==colors.isBufferGeometry)throw new Error("THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.Geometry or THREE.BufferGeometry instance.");var uv2,vertices=colors.getAttribute("position");if(builder.AddFloatAttributeToMesh(mesh,dracoEncoder.POSITION,vertices.count,vertices.itemSize,vertices.array),null!==(faces=colors.getIndex()))builder.AddFacesToMesh(mesh,faces.count/3,faces.array);else{for(var faces=new(65535<vertices.count?Uint32Array:Uint16Array)(vertices.count),i=0;i<faces.length;i++)faces[i]=i;builder.AddFacesToMesh(mesh,vertices.count,faces)}!0!==options.exportNormals||void 0!==(uv2=colors.getAttribute("normal"))&&builder.AddFloatAttributeToMesh(mesh,dracoEncoder.NORMAL,uv2.count,uv2.itemSize,uv2.array),!0===options.exportUvs&&(void 0!==(uv2=colors.getAttribute("uv"))&&builder.AddFloatAttributeToMesh(mesh,dracoEncoder.TEX_COORD,uv2.count,uv2.itemSize,uv2.array),void 0!==(uv2=colors.getAttribute("uv2"))&&builder.AddFloatAttributeToMesh(mesh,dracoEncoder.TEX_COORD,uv2.count,uv2.itemSize,uv2.array)),!0!==options.exportColor||void 0!==(colors=colors.getAttribute("color"))&&builder.AddFloatAttributeToMesh(mesh,dracoEncoder.COLOR,colors.count,colors.itemSize,colors.array);var encodedData=new dracoEncoder.DracoInt8Array;if(encoder.SetSpeedOptions(options.encodeSpeed||5,options.decodeSpeed||5),void 0!==options.encoderMethod&&encoder.SetEncodingMethod(options.encoderMethod),void 0!==options.quantization)for(i=0;i<5;i++)void 0!==options.quantization[i]&&encoder.SetAttributeQuantization(i,options.quantization[i]);var length=encoder.EncodeMeshToDracoBuffer(mesh,encodedData);if(dracoEncoder.destroy(mesh),0===length)throw new Error("THREE.DRACOExporter: Draco encoding failed.");for(var outputData=new Int8Array(new ArrayBuffer(length)),i=0;i<length;i++)outputData[i]=encodedData.GetValue(i);return dracoEncoder.destroy(encodedData),dracoEncoder.destroy(encoder),dracoEncoder.destroy(builder),outputData}},THREE.DRACOExporter.MESH_EDGEBREAKER_ENCODING=1,THREE.DRACOExporter.MESH_SEQUENTIAL_ENCODING=0,THREE.DRACOExporter.POINT_CLOUD=0,THREE.DRACOExporter.TRIANGULAR_MESH=1,THREE.DRACOExporter.INVALID=-1,THREE.DRACOExporter.POSITION=0,THREE.DRACOExporter.NORMAL=1,THREE.DRACOExporter.COLOR=2,THREE.DRACOExporter.TEX_COORD=3,THREE.DRACOExporter.GENERIC=4;